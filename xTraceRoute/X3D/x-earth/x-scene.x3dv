#X3D V3.3 utf8

PROTO Location [
   inputOutput SFBool animate FALSE
   inputOutput SFFloat latitude 0
   inputOutput SFFloat longitude 0
   inputOutput SFVec3f scale 0.01 0.01 0.01
]
{
   DEF Transform Transform {
      scale IS scale
      children [
         DEF TouchGroup Group {
            children [
               DEF Touch TouchSensor { }
               DEF Sphere Transform {
                  children [
                     Shape {
                        appearance Appearance {
                           material Material {
                              ambientIntensity 0.712006
                              diffuseColor 1 0.4 1
                              specularColor 1 0.3 1
                              shininess 0.81
                           }
                        }
                        geometry Sphere { }
                     }
                     DEF Hidden Transform {
                        translation 0 0 0.01
                        children Shape {
                           appearance Appearance {
                              material Material {
                                 transparency 1
                              }
                           }
                           geometry Disk2D {
                              innerRadius 0
                              outerRadius 2
                           }
                        }
                     }
                  ]
               }
            ]
         }
         DEF AnimatedCircle Switch {
            whichChoice 0
            children [
               Shape {
                  appearance Appearance {
                     material Material {
                        transparency 1
                     }
                     shaders DEF CircleShader PackagedShader {
                        inputOnly SFFloat set_fraction
                        language "MSL"
                        url "data:x-shader/x-metal,
#include <metal_stdlib>

using namespace metal;

struct x3d_VertexOut
{
   float4 texCoord;
   float4 position [[position]];
};

vertex
x3d_VertexOut
vertexShader (const unsigned int vertexId         [[ vertex_id  ]],
              const device x3d_VertexIn* vertices [[ buffer (0) ]],
              constant x3d_Uniforms & uniforms    [[ buffer (1) ]])
{
   x3d_VertexIn  in  = vertices [vertexId];
   x3d_VertexOut out = x3d_VertexOut ();
   
   out .texCoord = uniforms .textureMatrices [0] * in .texCoords [0];
   out .position = uniforms .projectionMatrix * uniforms .modelViewMatrix * in .point;
   
   return out;
}

constant float pi = 3.1415926535897932384626433832795;
constant float fraction [[ function_constant (0) ]];

fragment
float4
fragmentShader (const x3d_VertexOut in [[ stage_in ]])
{
   const auto color    = float3 (0.7, 0.8, 1);
   const auto texCoord = in .texCoord .xy / in .texCoord .w;
   const auto distance = length (texCoord * 2 - float2 (1, 1));
   const auto alpha    = pow ((sin ((distance + fraction) * 4 * pi) + 1) / 2, 2);

   return float4 (color, alpha);
}
"
                     }
                  }
                  geometry Disk2D {
                     outerRadius 6
                  }
               }
            ]
         }
         DEF Line Shape {
            geometry LineSet {
               vertexCount 3
               color Color {
                  color [
                     0 0.5 1,
                     0 0.5 1,
                     0 1 1,
                  ]
               }
               coord Coordinate {
                  point [
                     0 0 0,
                     0 0 5,
                     0 0 7,
                  ]
               }
            }
         }
      ]
   }
   
   DEF Timer TimeSensor {
      enabled IS animate
      cycleInterval 1.4
      loop TRUE
   }
   
   Script {
      inputOutput SFBool animate IS animate
      inputOutput SFFloat latitude IS latitude
      inputOutput SFFloat longitude IS longitude
      initializeOnly SFNode transform USE Transform
      initializeOnly SFNode circle USE AnimatedCircle

      url "ecmascript:
function initialize ()
{
   eventsProcessed ()
}

function set_animate (value, time)
{
   circle .whichChoice = value - 1;
}

function eventsProcessed ()
{
   const zAxis    = new SFVec3f (0, 0, 1);
   const position = getPosition (latitude, longitude);

   transform .translation = position;
   transform .rotation    = new SFRotation (zAxis, position);
}

function getPosition (latitude, longitude)
{
   var cosLat = Math.cos (latitude  * Math .PI / 180);
   var sinLat = Math.sin (latitude  * Math .PI / 180);
   var cosLon = Math.cos (longitude * Math .PI / 180);
   var sinLon = Math.sin (longitude * Math .PI / 180);

   return new SFVec3f (cosLat * sinLon, sinLat, cosLat * cosLon);
}
"
   }
   
   ROUTE Timer.fraction_changed TO CircleShader.set_fraction
}

PROTO Route [
   inputOutput SFNode fromLocation NULL
   inputOutput SFNode toLocation NULL
]
{
   Shape {
      appearance Appearance {
         material DEF Material Material {
            emissiveColor 1 0.4 1
         }
      }
      geometry DEF Lines LineSet {
         vertexCount 30
         coord DEF Coord Coordinate { }
      }
   }
   
   Script {
      inputOutput SFNode fromLocation IS fromLocation
      inputOutput SFNode toLocation IS toLocation
      initializeOnly SFNode coord USE Coord

      url "ecmascript:
function initialize ()
{
   eventsProcessed ();
}

function eventsProcessed ()
{
   coord .point .length = 0;
   
   var fLat = fromLocation .latitude;
   var fLon = fromLocation .longitude;
   var tLat = toLocation .latitude;
   var tLon = toLocation .longitude;
   
   if (tLon - fLon > 180) fLon += 360;

   for (var i = 0; i < 30; ++ i)
   {
      var t   = i / 29;
      var lat = lerp (fLat, tLat, t);
      var lon = lerp (fLon, tLon, t);
      var pos = getPosition (lat, lon);
      var s   = (1 - Math .pow (t * 2 - 1, 2)) * 0.2 + 1;
      
      coord .point [i] = pos .multiply (s);
   }
}

function getPosition (latitude, longitude)
{
   var cosLat = Math.cos (latitude  * Math .PI / 180);
   var sinLat = Math.sin (latitude  * Math .PI / 180);
   var cosLon = Math.cos (longitude * Math .PI / 180);
   var sinLon = Math.sin (longitude * Math .PI / 180);

   return new SFVec3f (cosLat * sinLon, sinLat, cosLat * cosLon);
}

function lerp (source, destination, t)
{
   return source + t * (destination - source);
}
"
   }
}

PROTO LocationGroup [
   inputOutput MFNode locations [ ]
]
{
   Group {
      children [
         DEF VP1 Viewpoint { }
         DEF VP2 Viewpoint { }
         DEF Locations Group {
            children IS locations
         }
         DEF Routes Group { }
      ]
   }
   
   Script {
      inputOutput MFNode locations IS locations
      initializeOnly SFNode vp1 USE VP1
      initializeOnly SFNode vp2 USE VP2
      initializeOnly SFNode routes USE Routes

      url "ecmascript:
function initialize ()
{
   set_locations (locations, 0);
}

function set_locations (value, time)
{
   if (value .length == 0)
   {
      routes .children .length = 0;
   }
   else
   {
      for (var i = 0; i < value .length - 1; ++ i)
         value [i] .animate = false;
      
      var current  = value [value .length - 1];
      var position = getPosition (current .latitude, current .longitude);
      var vp       = vp1 .isBound ? vp2 : vp1;
      
      current .animate = true;
      vp .position     = position .multiply (3);
      vp .orientation  = getOrientation (vp .position, new SFVec3f ());
      vp .set_bind     = true;
      
      for (var i = routes .children .length; i < value .length - 1; ++ i)
      {
         var previous = value [i];
         var current  = value [i + 1];
         var route    = Browser .currentScene .createProto ('Route');
         
         route .fromLocation = previous;
         route .toLocation   = current;
         
         routes .children [i] = route;
      }
   }
}

function getPosition (latitude, longitude)
{
   var cosLat = Math.cos (latitude  * Math .PI / 180);
   var sinLat = Math.sin (latitude  * Math .PI / 180);
   var cosLon = Math.cos (longitude * Math .PI / 180);
   var sinLon = Math.sin (longitude * Math .PI / 180);

   return new SFVec3f (cosLat * sinLon, sinLat, cosLat * cosLon);
}

function getOrientation (fromPoint, toPoint)
{
   var yAxis = new SFVec3f (0, 1, 0);
   var zAxis = new SFVec3f (0, 0, 1);

   var direction = fromPoint .subtract (toPoint);
   var rotation  = new SFRotation (zAxis, direction);
   var cameraUp  = rotation .multVec (yAxis);
   var N1        = direction .cross (cameraUp);
   var N2        = direction .cross (yAxis);
   var straight  = new SFRotation (N1, N2);

   return rotation .multiply (straight);
}
"
   }
}

LayerSet {
   order [1, 2]
   activeLayer 2
   layers [
      DEF Background Layer {
         isPickable FALSE
         children [
            NavigationInfo {
               headlight FALSE
               type "EXAMINE"
            }
            Background {
               skyColor 0 0 0.05
            }
            DEF DarkBlue DirectionalLight {
               color 0 0 0.05
               intensity 1
               direction 0 0 -1
            }
            DEF Magenta PointLight {
               color 1 0 1
               intensity 0.4
               location 4 -4 2
            }
            DEF LightBlue PointLight {
               color 0 1 1
               intensity 0.1
               location -6 4 4
            }
            Transform {
               children Shape {
                  appearance Appearance {
                     material Material {
                        diffuseColor 1 1 1
                     }
                  }
                  geometry Rectangle2D {
                     size 1000 1000
                  }
               }
            }
         ]
      }
      DEF Scene Layer {
         children [
            NavigationInfo {
               type "EXAMINE"
               headlight TRUE
               transitionType "LINEAR"
               transitionTime 3
            }
            DEF Initial Viewpoint {
               position 0 0 3
            }
            DEF Atmosphere Billboard {
               axisOfRotation 0 0 0
               children Transform {
                  translation -0.02 0.02 0
                  scale 1.1 1.1 1.1
                  children Shape {
                     appearance Appearance {
                        material Material {
                           diffuseColor 0 0 0
                           emissiveColor 0.8 0.9 1
                           transparency 0
                        }
                        texture ImageTexture {
                           url "x-athmosphere.png"
                        }
                     }
                     geometry Rectangle2D { }
                  }
               }
            }
            DEF Earth Inline {
               url "x-earth.x3dv"
            }
            DEF Locations LocationGroup { locations Location { } }
         ]
      }
   ]
}

DEF EnterWorldScript Script {
  url "ecmascript:
function initialize ()
{
   Browser .setBrowserOption (\"Shading\",          \"PHONG\");
   Browser .setBrowserOption (\"PrimitiveQuality\", \"HIGH\");
}
"
}
